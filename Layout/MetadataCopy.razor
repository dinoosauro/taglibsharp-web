@using Microsoft.FluentUI.AspNetCore.Components;
@using MetadataChange;

<FluentDialog>
    <FluentDialogHeader>
        <div>
            <h2>Copy metadata:</h2>
            <FluentButton Id="CloseDialogBtn" Appearance="Appearance.Lightweight" @onclick="() => Callback()" IconStart="@(new Icons.Regular.Size20.Dismiss())"></FluentButton>
            <FluentTooltip Anchor="CloseDialogBtn" Position="TooltipPosition.Left">Close the dialog without copying metadata</FluentTooltip>
        </div>
    </FluentDialogHeader>
    <FluentSelect TOption="string" @onchange="changedType">
        <FluentOption Value="0">Copy a file metadata to another one</FluentOption>
        <FluentOption Value="1">Copy a file metadata to all the others</FluentOption>
        <FluentOption Value="2">Copy files metadata to the ones that have the same file name</FluentOption>
        <FluentOption Value="3">Copy files metadata to the ones that have the same album name</FluentOption>
    </FluentSelect><br><br>
    <FluentCard>
        <h3>Copy settings:</h3>
        @if (!copyToSameName) {
            <p style="margin-top: 0px;">Copy from:</p>
            <FluentSelect Items="Container" OptionText="@(item => item.file)" OptionValue="@(item => item.id)"
                @bind-Value="CurrentPosition"></FluentSelect>
        @if (!applyToEverything && !copyToSameAlbum)
        {
            <p>To:</p>
            <div class="innerSelectDiv">
            <FluentSelect Items="Container" OptionText="@(item => item.file)" OptionValue="@(item => item.id)"
                @bind-Value="selectedId"></FluentSelect>
            </div><br>
        } else {
            <br><br>
        }
        }
        @if (copyToSameName) {
            <label class="labelFlex">Copy from the file with the extension: <FluentTextField @bind-Value="copySource"></FluentTextField></label><br>
        }
        <FluentCheckbox @bind-Value="overwrite">Overwrite existing tags</FluentCheckbox><br><br>
        <FluentCheckbox @bind-Value="copyImage">Copy album art</FluentCheckbox><br><br>
        <FluentCheckbox @bind-Value="copyCustomMetadata">Copy custom metadata</FluentCheckbox><br><br>
        <FluentCheckbox @bind-Value="dontCopyTrackSpecificValues">Don't copy track-specific metadata (ex: title, track position etc.)</FluentCheckbox>
    </FluentCard><br>
        <FluentButton @onclick="ApplyItems" Appearance="Appearance.Accent">Apply</FluentButton>
</FluentDialog>

@code {
    /// <summary>
    /// The list of all the files that are loaded in the website
    /// </summary>
    [Parameter]
    public required List<TagInfoContainer> Container { get; set; }
    /// <summary>
    /// The Action to call for closing this dialog
    /// </summary>
    [Parameter]
    public required Action Callback { get; set; }
    /// <summary>
    /// The selected file (SOURCE)
    /// </summary>
    [Parameter]
    public required string CurrentPosition { get; set; }
    /// <summary>
    /// The selected file (DESTINATION)
    /// </summary>
    private string selectedId = "0";
    /// <summary>
    /// If the metadata should be copied to all the files
    /// </summary>
    private bool applyToEverything = false;
    /// <summary>
    /// If the metadata should be overwritten
    /// </summary>
    private bool overwrite = false;
    /// <summary>
    /// If also custom metadata should be saved
    /// </summary>
    private bool copyCustomMetadata = false;
    /// <summary>
    /// If also the image shuold be copied
    /// </summary>
    private bool copyImage = true;
    /// <summary>
    /// If enabled, the script will copy metadata from the files that have the same name (and different extensions) 
    /// </summary>
    private bool copyToSameName = false;
    /// <summary>
    /// If track-specific values (ex: track title, track artists etc.) shouldn't be copied 
    /// </summary>
    private bool dontCopyTrackSpecificValues = false;
    /// <summary>
    /// If the metadata of that file should be copied to every file that has the same album name
    /// </summary>
    private bool copyToSameAlbum = false;
    /// <summary>
    /// When copying metadata from the files with the same name, the source file will be the first that matches this extension
    /// </summary>
    private string copySource = "";

    /// <summary>
    /// Update the variables that tell the application which files should be updated.
    /// </summary>
    private void changedType(ChangeEventArgs e) {
        applyToEverything = e.Value?.ToString() == "1";
        copyToSameName = e.Value?.ToString() == "2";
        copyToSameAlbum = e.Value?.ToString() == "3";
    }

    /// <summary>
    /// The function that copies the basic tags, and the album art, from a file to another
    /// </summary>
    /// <param name="source">The TagLib.File to copy from</param>
    /// <param name="output">The TagLib.File to copy to</param>
    private void CopyTag(TagLib.File source, TagLib.File output)
    {
        string[]? tempPerformers = null; // A bug in TagLib Sharp causes an Exception when copying the performers tag using "CopyTo" in Apple container. We'll add it manually.
        
        if (CustomMetadataFormat.GetSuggestedContainer(output.Tag.TagTypes.ToString().ToLower()) ==
        CustomMetadataFormat.CustomMetadataTypes.APPLE)
        { 
            tempPerformers = source.Tag.Performers;
            source.Tag.Performers = null;
        }
        // Now, if the user wants to keep the track-specific metadata, we'll store them in a string array. The joinGuid is used to join some string arrays.
        string joinGuid = Guid.NewGuid().ToString();
        string[]? trackSpecificParameters = dontCopyTrackSpecificValues ? [output.Tag.Track.ToString(), string.Join(joinGuid, output.Tag.Composers), string.Join(joinGuid, output.Tag.Performers), output.Tag.Comment, output.Tag.Conductor, output.Tag.Description, output.Tag.Title] : null;
        // If the user wants to keep the album art, we have to create a new array that'll contain the current images, since CopyTo will replace the old array with the source one.
        TagLib.IPicture[]? prevImages = copyImage ? null : output.Tag.Pictures.AsEnumerable().ToArray();
        source.Tag.CopyTo(output.Tag, overwrite);
        // We'll now have to copy some other standard metadata that TagLib Sharp doesn't copy.
        if (!dontCopyTrackSpecificValues && (overwrite || output.Tag.Lyrics == null || output.Tag.Lyrics == "")) output.Tag.Lyrics = source.Tag.Lyrics;
        if (overwrite || output.Tag.AlbumArtistsSort == null || output.Tag.AlbumArtistsSort.Count() == 0) output.Tag.AlbumArtistsSort = source.Tag.AlbumArtistsSort;
        if (overwrite || output.Tag.AlbumSort == null || output.Tag.AlbumSort == "") output.Tag.AlbumSort = source.Tag.AlbumSort;
        if (!dontCopyTrackSpecificValues && (overwrite || output.Tag.ComposersSort == null || output.Tag.ComposersSort.Count() == 0)) output.Tag.ComposersSort = source.Tag.ComposersSort;
        if (!dontCopyTrackSpecificValues && (overwrite || output.Tag.TitleSort == null || output.Tag.TitleSort == "")) output.Tag.TitleSort = source.Tag.TitleSort;
        output.Tag.Pictures = copyImage ? source.Tag.Pictures : prevImages;
        if (tempPerformers != null)
        {
            output.Tag.Performers = tempPerformers;
            source.Tag.Performers = tempPerformers;
        }
        if (trackSpecificParameters != null) { // Restore track-specific parameters
            output.Tag.Track = uint.Parse(trackSpecificParameters[0]);
            output.Tag.Composers = trackSpecificParameters[1].Split(joinGuid);
            output.Tag.Performers = trackSpecificParameters[2].Split(joinGuid);
            output.Tag.Comment = trackSpecificParameters[3];
            output.Tag.Conductor = trackSpecificParameters[4];
            output.Tag.Description = trackSpecificParameters[5];
            output.Tag.Title = trackSpecificParameters[6];
        }
        // Now let's restore customm metadata if the user wants so. Let's start by getting the suggested container of both input and output.
        CustomMetadataFormat.CustomMetadataTypes? sourceType = CustomMetadataFormat.GetSuggestedContainer(source.Tag.TagTypes.ToString().ToLower());
        CustomMetadataFormat.CustomMetadataTypes? outputType = CustomMetadataFormat.GetSuggestedContainer(output.Tag.TagTypes.ToString().ToLower());
        if (sourceType != null && outputType != null) {
            if (CustomMetadataFormat.CopiedProps.TryGetValue((CustomMetadataFormat.CustomMetadataTypes) sourceType, out string[] paramsToNotCopy)) { // Get the non-custom parameters, that should be skipped since they've been already copied.
                // We'll now get all of the metadata to copy
                var allSourceMetadata = CustomMetadataUtils.GetAllTags((CustomMetadataFormat.CustomMetadataTypes) sourceType, source, null);
                // If it's a MP3 file, we'll also add the MP3 tag type to create.
                List<TagLib.Id3v2.Frame>? mp3Frames = sourceType == CustomMetadataFormat.CustomMetadataTypes.ID3 ? ((TagLib.Id3v2.Tag)source.GetTag(TagLib.TagTypes.Id3v2, true)).GetFrames().ToList() : null;
                foreach (var metadata in allSourceMetadata) {
                    if (paramsToNotCopy.Contains(metadata.key)) continue;
                    string mp3Tag = "0";
                    if (mp3Frames != null) {
                        TagLib.Id3v2.Frame? possibleFrame = mp3Frames.Find(item => item.FrameId == metadata.key);
                        if (possibleFrame != null) {
                            if (possibleFrame is TagLib.Id3v2.PrivateFrame) mp3Tag = "1";
                            if (possibleFrame is TagLib.Id3v2.CommentsFrame) mp3Tag = "2";
                        }
                    } 
                    CustomMetadataUtils.UpdateCustomValueHandle((CustomMetadataFormat.CustomMetadataTypes)outputType, output, metadata.key, string.Join(", ", metadata.values), metadata.meanstring ?? "com.apple.iTunes", mp3Tag); // And we'll add the new metadata to to the output file.
                }
            }
        }
    }
    /// <summary>
    /// Copy the metadata from the source to the destination
    /// </summary>

    private void ApplyItems()
    {
        Container[int.Parse(CurrentPosition)].tag.Save(); // Save the current tag, since it might be re-created later.
        if (!applyToEverything && !copyToSameName && !copyToSameAlbum)
        {
            if (selectedId != CurrentPosition) CopyTag(Container[int.Parse(CurrentPosition)].tag, Container[int.Parse(selectedId)].tag); // The two files are different: we can copy the metadata
        }
        else if (!copyToSameName && !copyToSameAlbum) // The selected file must be copied everywhere.
        {
            foreach (TagInfoContainer infoContainer in Container)
            {
                if (infoContainer.id != CurrentPosition) CopyTag(Container[int.Parse(CurrentPosition)].tag, infoContainer.tag); // Ignore the source file
            }
        } else if (!copyToSameAlbum) { // Copy all the files that have the same name
            foreach (List<TagInfoContainer> applyThis in (new GetFilesWithSameName(Container)).allowedValues.Values) { 
                /// <summary>
                /// The file that will be used as a source: the first that ends with the extension
                /// </summary>
                TagInfoContainer? source = applyThis.Find(item => item.file.EndsWith(copySource)); 
                if (source != null) {
                    source.tag.Save();
                    foreach (TagInfoContainer destination in applyThis) {
                        if (destination != source) CopyTag(source.tag, destination.tag);
                    }
                }

            }
        } else {
            foreach (TagInfoContainer container in Container.Where((item, position) => position != int.Parse(CurrentPosition) && item.tag.Tag.Album == Container[int.Parse(CurrentPosition)].tag.Tag.Album)) {
                CopyTag(Container[int.Parse(CurrentPosition)].tag, container.tag);
            }
        }
        Callback();
    }

}