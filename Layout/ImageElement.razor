@using Microsoft.FluentUI.AspNetCore.Components;
@using Microsoft.JSInterop;
@using MetadataChange;
@using System.IO.Compression
@inject IJSRuntime JS;
@inject IToastService ToastService

<FluentDialog Style="z-index: 998 !important">
        <FluentDialogHeader>
        <div>
            <h2>Update image content:</h2>
            <FluentButton Id="CloseDialogBtn" Appearance="Appearance.Lightweight" @onclick="() => GetUpdatedList(imageTag, ApplyDestination.DISCARD_EDITS)" IconStart="@(new Icons.Regular.Size20.Dismiss())"></FluentButton>
            <FluentTooltip Anchor="CloseDialogBtn" Position="TooltipPosition.Left">Close the dialog, without saving the edits</FluentTooltip>
        </div>
    </FluentDialogHeader>
    <InputFile OnChange="NextAlbumArt" id="albumArtPicker" style="display: none;" ></InputFile>
    @if (addImageBytes.Length > 0) {
        <h3>Encoding options:</h3>
        <FluentAccordion>
            <FluentAccordionItem Heading="Encoding Options">
                        <FluentIcon Value="@(new Icons.Regular.Size24.DrawImage())" Color="@Color.Neutral" Slot="start" />
                <label class="labelFlex">
                    JPEG quality:
        <FluentSlider Min="0.01" Max="1" Step="0.01" @bind-Value="compressionQuality"></FluentSlider><br>
                </label><br>
        <label class="labelFlex">
            Maximum width (in pixels)
            <FluentTextField type="number" @bind-Value="maxWidth"></FluentTextField>
        </label><br>
        <label class="labelFlex">
            Maximum height (in pixels)
            <FluentTextField type="number" @bind-Value="maxHeight"></FluentTextField>
        </label>
        </FluentAccordionItem>
        <FluentAccordionItem Heading="Advanced options">
            <FluentIcon Value="@(new Icons.Regular.Size24.Sparkle())" Color="@Color.Neutral" Slot="start" />
            <p style="margin-top: 0px;">Album art custom category:</p>
            <FluentListbox Height="150px" Items="@PicturesType.pictureTypes" OptionText="@(item => item.description)" OptionValue="@(item => item.id.ToString())" @bind-Value="pictureChosenType"></FluentListbox><br>
            <FluentCheckbox @bind-Value="reEncodeImage">Re-encode the image</FluentCheckbox><br>
            @if (!reEncodeImage) {
                <br>
                <label class="labelFlex">
                    Image mimetype
                    <FluentTextField @bind-Value="imageReEncodingMimeType"></FluentTextField>
                </label>
            }
        </FluentAccordionItem>
        </FluentAccordion><br>
        <FluentButton @onclick="AddNewImage" Appearance="Appearance.Accent">Add image</FluentButton><br><br>
    } else if (imageTag.Count > 0)
    {
        <FluentSelect Items="@imageTag" OptionValue="@(tag => tag.id)"
            @onchange='(val) => UpdateSelectedPicture(val.Value.ToString())'
            OptionText="@(tag => tag.picture.Type + " - " + tag.picture.Description + " [" + (int.Parse(tag.id) + 1) + "]")">
        </FluentSelect><br><br>
        <FluentCard>
            <div style="display: flex; justify-content: center;">
            <img style="max-width: 300px; max-height: 300px; border-radius: 8px;" id="imageSource">
            </div><br>
        @if (addImageBytes.Length == 0) {
            <div class="flexContainer">
                <FluentButton @onclick='() => JS.InvokeVoidAsync("clickPictureImage")'>Add new album art</FluentButton>
                <FluentButton @onclick='RemoveItem'>Remove this album art</FluentButton>
            </div>
            }
        </FluentCard>
    }
    @if (imageTag.Count == 0 && addImageBytes.Length == 0) {
        <br>
        <FluentButton @onclick='() => JS.InvokeVoidAsync("clickPictureImage")'>Add new album art</FluentButton><br>
    }
    @if (addImageBytes.Length == 0) {
        <br>
        <div class="labelFlex fullWidthChildren">
            <FluentMenuButton Text="Save album art(s)" OnMenuChanged="SaveImageEvent" Items="@SaveOptions"></FluentMenuButton>
            <FluentMenuButton ButtonAppearance="Appearance.Neutral" Text="Export album art(s)" Items="@ExportOptionsPicker" OnMenuChanged='@(async (args) => {
                await ExportImage((ExportOptions)int.Parse(args.Id?.ToString() ?? "0"));
            })'></FluentMenuButton>
        </div>
    }
    </FluentDialog>
    <script>
        /**
        * Show the album art in the img element from a byte array
        */
        function updateImageSource(bytes) {
            document.getElementById("imageSource").src = URL.createObjectURL(new Blob([bytes]));
        }
        /**
        * Choose the new image file
        */
        function clickPictureImage() {
            document.getElementById("albumArtPicker").click();
        }
        /**
        * Converts the image in a JPEG, following the provided values: a byte array, the image quality, the maximum height and the maximum width
        */
        function getImageBlob(bytes, quality, maxHeight, maxWidth) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement("canvas");
                    // Format output width/height
                    if ((img.width > img.height && img.width > +maxWidth) || img.height > +maxHeight) {
                        canvas.width = img.width > img.height ? +maxWidth : Math.floor(+maxHeight * (img.width / img.height));
                        canvas.height = img.width > img.height ? Math.floor(+maxWidth / (img.width / img.height)) : +maxHeight;
                    } else {
                        canvas.width = img.width;
                        canvas.height = img.height;
                    }
                    canvas.getContext("2d").drawImage(img, 0, 0, canvas.width, canvas.height);
                    canvas.toBlob((blob) => {
                        blob.arrayBuffer().then((buffer) => resolve(new Uint8Array(buffer))); 
                    }, "image/jpeg", +quality)
                }
                img.onerror = () => {
                    console.warn(img.src);
                    resolve(new Uint8Array([]));
                }
                img.src = URL.createObjectURL(new Blob([bytes]));
            })
        }
    </script>

@code {
    /// <summary>
    /// The list of pictures of the current tag
    /// </summary>
    [Parameter]
    public required TagLib.IPicture[] imageTags { get; set; }
    [Parameter]
    public required List<TagInfoContainer> files {get; set;}
    [Parameter]
    public required int fileEditPosition {get; set;}
    [Parameter]
    public required Action Callback {get; set;}
    [Parameter]
    public required Action<byte[], string> DownloadFile {get; set;}
    /// <summary>
    /// The list of the images to add to the currently-selected tag
    /// </summary>
    private List<ImageTagCount> imageTag = new List<ImageTagCount>();
    /// <summary>
    /// The byte array of the selected image.
    /// If this is empty, the UI will show the already-added images. Otherwise, the image compression UI will be shown (so that the user can add the albunm art).
    /// </summary>
    private byte[] addImageBytes = [];
    /// <summary>
    /// The position in the "imageTags" array of the image the user is seeing
    /// </summary>

    private int selectedImage = 0;
    /// <summary>
    /// The quality of the output JPEG Image
    /// </summary>
    private double compressionQuality = 0.9;
    /// <summary>
    /// The maximum height of the JPEG image
    /// </summary>
    private string maxHeight = "700";
    /// <summary>
    /// The maximum width of the JPEG image
    /// </summary>
    private string maxWidth = "700";
    /// <summary>
    /// The ID of the image category of the new image
    /// </summary>
    private string pictureChosenType = "3";
    /// <summary>
    /// If the new image should be re-encoded
    /// </summary>
    private bool reEncodeImage = true;
    /// <summary>
    /// The mimetype of the provided image. This is used only if the user provides their own image, and doesn't want to re-encode it.
    /// </summary>
    private string imageReEncodingMimeType = "";
    /// <summary>
    /// The Dictionary of possible methods to save the album image
    /// </summary>
    private Dictionary<string, string> SaveOptions = new(){
        {"0", "Save (this file)"},
        {"2", "Save (files with the same name)"},
        {"3", "Save (files with the same album)"},
        {"1", "Save (everywhere)"}
    };

    /// <summary>
    /// Description to the "Export images" FluentMenuButton
    /// </summary>
    private Dictionary<string, string> ExportOptionsPicker = new() {
        {"0", "Export this image"},
        {"1", "Export all the images of this file"},
        {"2", "Export all images of all loaded files"}
    };

    /// <summary>
    /// What images should be exported
    /// </summary>
    public enum ExportOptions {
        /// <summary>
        /// Export only the selected image
        /// </summary>
        EXPORT_THIS_IMAGE = 0,
        /// <summary>
        /// Export all the images included in the selected file
        /// </summary>
        EXPORT_ALL_IMAGES = 1,
        /// <summary>
        /// Export all the images of all opened files
        /// </summary>
        EXPORT_ALL_IMAGES_OF_EVERYTHING = 2
    }
    
    /// <summary>
    /// Get the path for the exported album art
    /// <param name="sourcePath">the source path of the MP3 file</param>
    /// <param name="position">the number of the image in the array of images contained in the file</param>
    /// <param name="string">the mimetype of the output image</param>
    /// </summary>
    private string GetExportedImagePath(string sourcePath, int position, string mimetype) {
        if (sourcePath.IndexOf("/") == -1) return $"[{position}] {sourcePath[..sourcePath.LastIndexOf(".")]}.{(mimetype == "image/jpeg" ? "jpg" : mimetype[(mimetype.IndexOf("/") + 1)..])}";
        return $"{sourcePath[..sourcePath.LastIndexOf("/")]}/[{position}] {sourcePath[(sourcePath.LastIndexOf("/") + 1)..sourcePath.LastIndexOf(".")]}.{(mimetype == "image/jpeg" ? "jpg" : mimetype[(mimetype.IndexOf("/") + 1)..])}";
    }
    /// <summary>
    /// Export one or more images embedded in the audio/video file
    /// </summary>
    private async Task ExportImage(ExportOptions exportOptions) {
        string ToastId = Guid.NewGuid().ToString();
        ProgressToastParams toastParams = new ProgressToastParams(){
            Title = "Operation starting...",
            Max = (exportOptions == ExportOptions.EXPORT_ALL_IMAGES ? imageTags.Count() : files.Count()),
            Progress = 0
        };
        if (exportOptions != ExportOptions.EXPORT_THIS_IMAGE) ToastService.ShowToast<Layout.ProgressToast, ProgressToastParams>(new ToastParameters<ProgressToastParams>()
            {
                Id = ToastId,
                Intent = ToastIntent.Custom,
                Timeout = 0,
                Icon = (new Icons.Regular.Size20.ImageCopy(), Color.Accent),
                Content = toastParams
            });
        switch (exportOptions) {
            case ExportOptions.EXPORT_THIS_IMAGE: { // Download the single image, without any zip file
                DownloadFile(imageTag.ElementAt(selectedImage).picture.Data.ToArray(), $"{files[fileEditPosition].file[..files[fileEditPosition].file.LastIndexOf(".")]}.{(imageTag.ElementAt(selectedImage).picture.MimeType != null ? imageTag.ElementAt(selectedImage).picture.MimeType[(imageTag.ElementAt(selectedImage).picture.MimeType.IndexOf("/") + 1)..] : "jpg")}");
                break;
            }
            case ExportOptions.EXPORT_ALL_IMAGES: { // Get all images of the current file, and download them
                using (MemoryStream stream = new MemoryStream()) {
                    using (ZipArchive archive = new ZipArchive(stream, System.IO.Compression.ZipArchiveMode.Create, true)) {
                        int i = 1;
                        foreach (TagLib.IPicture picture in imageTags) {
                            ZipArchiveEntry entry = archive.CreateEntry(GetExportedImagePath(files[fileEditPosition].file, i, picture.MimeType ?? "image/jpg"), CompressionLevel.Fastest);
                            using (Stream write = entry.Open()) await write.WriteAsync(picture.Data.ToArray());
                            toastParams.Title = $"Added image {i} to the zip file";
                            i++;
                            toastParams.Progress++;
                            toastParams.UpdateState?.Invoke();
                            await Task.Delay(25);
                        }
                    }
                    DownloadFile(stream.ToArray(), $"{files[fileEditPosition].file[..files[fileEditPosition].file.LastIndexOf(".")]}.zip");
                }
                break;
            }
            case ExportOptions.EXPORT_ALL_IMAGES_OF_EVERYTHING: { // Get all the images contained in every loaded file, and save them in a zip file.
                using (MemoryStream stream = new MemoryStream()) {
                    using (ZipArchive archive = new ZipArchive(stream, ZipArchiveMode.Create, true)) {
                        foreach (TagInfoContainer file in files) {
                            toastParams.Title = $"Adding images of {file.file}";
                            toastParams.Progress++;
                            toastParams.UpdateState?.Invoke();
                            await Task.Delay(25);
                            if (file.tag.Tag.Pictures == null) continue;
                            int i = 1;
                            foreach (TagLib.IPicture picture in file.tag.Tag.Pictures) {
                                ZipArchiveEntry entry = archive.CreateEntry(GetExportedImagePath(file.file, i, picture.MimeType ?? "image/jpg"), CompressionLevel.Fastest);
                                using (Stream write = entry.Open()) await write.WriteAsync(picture.Data.ToArray());
                                i++;
                            }
                        }
                    }
                    DownloadFile(stream.ToArray(), $"EmbeddedImages-{DateTime.Now.ToString().Replace("/", "-")}.zip");
                }
                break;
            }
        }
        toastParams.Title = "Images exported!";
        toastParams.Max = 1;
        toastParams.Progress = 1;
        toastParams.UpdateState?.Invoke();
        await Task.Delay(3500);
        ToastService.CloseToast(ToastId);
    }

    /// <summary>
    /// Update the Album Art for the selected items
    /// </summary>
    /// <param name="images">A list of the new images to add</param>
    /// <param name="destination">If the image should be applied only to the selected image, to everything, or if the edits
    /// should be discarded.</param>
    private void GetUpdatedList(List<ImageElement.ImageTagCount> images, ImageElement.ApplyDestination destination)
    {
        TagLib.IPicture[] pictures = images.Select(item => item.picture).ToArray();
        switch (destination)
        {
            case ImageElement.ApplyDestination.APPLY_CURRENT:
                files[fileEditPosition].tag.Tag.Pictures = pictures;
                break;
            case ImageElement.ApplyDestination.APPLY_EVERYTHING:
                foreach (TagInfoContainer file in files) file.tag.Tag.Pictures = pictures;
                break;
            case ImageElement.ApplyDestination.APPLY_SAME_NAME:
                var dictionary = (new GetFilesWithSameName(files)).allowedValues;
                if (dictionary.TryGetValue(files[fileEditPosition].file.Substring(0, files[fileEditPosition].file.LastIndexOf(".")), out
                List<TagInfoContainer> applyToThis))
                {
                    foreach (TagInfoContainer apply in applyToThis) apply.tag.Tag.Pictures = pictures;
                }
                break;
            case ImageElement.ApplyDestination.APPLY_SAME_ALBUM:
                foreach (TagInfoContainer file in files)
                {
                    if (file.tag.Tag.Album == files[fileEditPosition].tag.Tag.Album) file.tag.Tag.Pictures = pictures;
                }
                break;

        }
        Callback();
    }

    /// <summary>
    /// The event called when the user has chosen to save the album arts.
    /// </summary>
    private void SaveImageEvent(MenuChangeEventArgs e) {
        GetUpdatedList(imageTag, (ApplyDestination)int.Parse(e.Id ?? "0"));
    }

    protected override void OnAfterRender(bool firstRender) {
        base.OnAfterRender(firstRender);
        ReadImage();
    }

    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        for (int i = 0; i < imageTags.Length; i++)
        {
            imageTag.Add(new ImageTagCount(imageTags[i], i.ToString())); // Populate the array of available images
        }
    }
    /// <summary>
    /// Remove an album art from the file
    /// </summary>
    private async Task RemoveItem() {
        imageTag.RemoveAt(selectedImage);
        for (int i = 0; i < imageTag.Count; i++) imageTag[i].id = i.ToString();
    }
    /// <summary>
    /// Create a TagLib.Picture for the selected image, and add it to the array. 
    /// </summary>
    private async Task AddNewImage() {
        byte[] reEncodedCanvas = reEncodeImage ? await JS.InvokeAsync<byte[]>("getImageBlob", [addImageBytes, compressionQuality, maxHeight, maxWidth]) : addImageBytes; // The re-encoding is done using JavaScript's Canvas API
        if (reEncodedCanvas.Length > 0) {
            TagLib.Picture picture = new TagLib.Picture();
            picture.Type = (TagLib.PictureType) int.Parse(pictureChosenType);
            picture.MimeType = reEncodeImage ? "image/jpeg" : imageReEncodingMimeType;
            picture.Data = reEncodedCanvas;
            imageTag.Add(new ImageTagCount(picture, imageTag.Count.ToString()));
        }
        addImageBytes = []; // By making this blank, the UI will go back to showing the available images
    }
    /// <summary>
    /// The callback called when the user has selected a new album art to add. The only thing this does is converting the InputFileEventArg to a Byte[]
    /// </summary>
    private async Task NextAlbumArt(InputFileChangeEventArgs e) {
        Stream copyStream = e.File.OpenReadStream(maxAllowedSize: 1024 * 1024 * 1024);
        using MemoryStream stream = new MemoryStream();
        await copyStream.CopyToAsync(stream);
        addImageBytes = stream.ToArray();
    }
    /// <summary>
    /// By providing the ID of the image, this image will be shown
    /// <param name="value">A string that is the same value of the ID (so, the position in the array)</param>
    /// </summary>
    private async Task UpdateSelectedPicture(string value)
    {
        selectedImage = int.Parse(value);
        ReadImage();
    }
    /// <summary>
    /// Update the image HTMLElement with the selected image
    /// </summary>
    private async Task ReadImage()
    {
        await JS.InvokeVoidAsync("wakeUp"); // For some reason, I need to call a void before updating the image. Otherwise, the next void isn't executed.
        await JS.InvokeVoidAsync("updateImageSource", [imageTag[selectedImage].picture.Data.ToArray()]);
    }
    /// <summary>
    /// The class that contains all the necessary items for the TagLib.IPicture edit
    /// </summary>
    /// <param name="picture">The image interface, ready for TagLib</param>
    /// <param name="id">An ID for the current image. Currently, this is the entry in the List.</param>
    public class ImageTagCount(TagLib.IPicture picture, string id)
    {
        /// <summary>
        /// The image interface, ready for TagLib
        /// </summary>
        public TagLib.IPicture picture = picture;
        /// <summary>
        /// An ID for the current image. Currently, this is the entry in the List.
        /// </summary>
        public String id = id;
    }
    /// <summary>
    /// The enum that tells the main script what should be done with the new edits
    /// </summary>
    public enum ApplyDestination {
        /// <summary>
        /// The user has closed the dialog without saving. Discard all the edits.
        /// </summary>
        DISCARD_EDITS = -1,
        /// <summary>
        /// Apply the new edits only to the current file
        /// </summary>
        APPLY_CURRENT = 0,
        /// <summary>
        /// Apply the new edits to every file
        /// </summary>
        APPLY_EVERYTHING = 1,
        /// <summary>
        /// Apply the new edits to the files that have the same file name
        /// </summary>
        APPLY_SAME_NAME = 2,
        /// <summary>
        /// Apply the new edits to the files that have the same album
        /// </summary>
        APPLY_SAME_ALBUM = 3
    }
}